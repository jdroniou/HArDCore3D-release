\hypertarget{basis_8hpp}{}\doxysection{src/\+Common/basis.hpp File Reference}
\label{basis_8hpp}\index{src/Common/basis.hpp@{src/Common/basis.hpp}}
{\ttfamily \#include $<$boost/multi\+\_\+array.\+hpp$>$}\newline
{\ttfamily \#include $<$mesh.\+hpp$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$polynomialspacedimension.\+hpp$>$}\newline
{\ttfamily \#include $<$quadraturerule.\+hpp$>$}\newline
Include dependency graph for basis.\+hpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{basis_8hpp__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{basis_8hpp__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1MonomialPowers}{HAr\+DCore3\+D\+::\+Monomial\+Powers$<$ Geometric\+Support $>$}}
\begin{DoxyCompactList}\small\item\em Compute vectors listing the powers of monomial basis functions (for a cell or face, only specializations are relevant) up to a certain degree. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1MonomialPowers_3_01Cell_01_4}{HAr\+DCore3\+D\+::\+Monomial\+Powers$<$ Cell $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1MonomialPowers_3_01Face_01_4}{HAr\+DCore3\+D\+::\+Monomial\+Powers$<$ Face $>$}}
\item 
class \mbox{\hyperlink{classHArDCore3D_1_1MonomialScalarBasisCell}{HAr\+DCore3\+D\+::\+Monomial\+Scalar\+Basis\+Cell}}
\begin{DoxyCompactList}\small\item\em Scalar monomial basis on a cell. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1MonomialScalarBasisFace}{HAr\+DCore3\+D\+::\+Monomial\+Scalar\+Basis\+Face}}
\begin{DoxyCompactList}\small\item\em Scalar monomial basis on a face. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1MonomialScalarBasisEdge}{HAr\+DCore3\+D\+::\+Monomial\+Scalar\+Basis\+Edge}}
\begin{DoxyCompactList}\small\item\em Scalar monomial basis on an edge. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1Family}{HAr\+DCore3\+D\+::\+Family$<$ Basis\+Type $>$}}
\item 
class \mbox{\hyperlink{classHArDCore3D_1_1TensorizedVectorFamily}{HAr\+DCore3\+D\+::\+Tensorized\+Vector\+Family$<$ Scalar\+Family\+Type, N $>$}}
\begin{DoxyCompactList}\small\item\em Vector family obtained by tensorization of a scalar family. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1MatrixFamily}{HAr\+DCore3\+D\+::\+Matrix\+Family$<$ Scalar\+Family\+Type, N $>$}}
\begin{DoxyCompactList}\small\item\em Matrix family obtained from a scalar family. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1TangentFamily}{HAr\+DCore3\+D\+::\+Tangent\+Family$<$ Scalar\+Family\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Vector family for polynomial functions that are tangent to a certain place (determined by the generators) \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1ShiftedBasis}{HAr\+DCore3\+D\+::\+Shifted\+Basis$<$ Basis\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Generate a basis where the function indices are shifted. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1RestrictedBasis}{HAr\+DCore3\+D\+::\+Restricted\+Basis$<$ Basis\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Generate a basis restricted to the first \char`\"{}dimension\char`\"{} functions. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1GradientBasis}{HAr\+DCore3\+D\+::\+Gradient\+Basis$<$ Basis\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Basis for the space of gradients of polynomials. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1CurlBasis}{HAr\+DCore3\+D\+::\+Curl\+Basis$<$ Basis\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Basis for the space of curls of polynomials. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1DivergenceBasis}{HAr\+DCore3\+D\+::\+Divergence\+Basis$<$ Basis\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Basis (or rather family) of divergence of an existing basis. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1RolyComplBasisCell}{HAr\+DCore3\+D\+::\+Roly\+Compl\+Basis\+Cell}}
\begin{DoxyCompactList}\small\item\em Basis for the complement R$^\wedge$\{c,k\}(T) in P$^\wedge$k(T)$^\wedge$3 of the range of curl. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1GolyComplBasisCell}{HAr\+DCore3\+D\+::\+Goly\+Compl\+Basis\+Cell}}
\begin{DoxyCompactList}\small\item\em Basis for the complement G$^\wedge$\{c,k\}(T) in P$^\wedge$k(T)$^\wedge$3 of the range of grad. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1RolyComplBasisFace}{HAr\+DCore3\+D\+::\+Roly\+Compl\+Basis\+Face}}
\begin{DoxyCompactList}\small\item\em Basis for the complement R$^\wedge$\{c,k\}(F) in P$^\wedge$k(F)$^\wedge$2 of the range of the vectorial rotational on a face. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classHArDCore3D_1_1GolyComplBasisFace}{HAr\+DCore3\+D\+::\+Goly\+Compl\+Basis\+Face}}
\begin{DoxyCompactList}\small\item\em Basis for the complement G$^\wedge$\{c,k\}(F) in P$^\wedge$k(F)$^\wedge$2 of the range of the gradient on a face. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Basis\+Type, Basis\+Function $>$}}
\begin{DoxyCompactList}\small\item\em Basis evaluation traits. Only specialization of \textquotesingle{}Basis\+Function\textquotesingle{} (=Function, Gradient, Curl or Divergence) are relevant, and determines what kind of value we want to evaluate. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Function_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Basis\+Type, Function $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Gradient_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Basis\+Type, Gradient $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Curl_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Basis\+Type, Curl $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Divergence_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Basis\+Type, Divergence $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Hessian_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Basis\+Type, Hessian $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01CurlCurl_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Basis\+Type, Curl\+Curl $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBasadb35b75fb171fb1d9154a129a3c3414}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Tensorized\+Vector\+Family$<$ Scalar\+Basis\+Type, N $>$, Function $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBasac6dfb25d40fd254551d4194b76f2160}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Tensorized\+Vector\+Family$<$ Scalar\+Basis\+Type, N $>$, Gradient $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBas16e94cc3561d5df4f5b07f40947ddc80}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Tensorized\+Vector\+Family$<$ Scalar\+Basis\+Type, N $>$, Curl $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBasf7970a904fb5bf5e0964fdf032f37682}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Tensorized\+Vector\+Family$<$ Scalar\+Basis\+Type, N $>$, Divergence $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBas97b5b029df1c36bf3d3b9b6dc9ed6bc8}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Tensorized\+Vector\+Family$<$ Scalar\+Basis\+Type, N $>$, Curl\+Curl $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01MatrixFamily_3_01ScalarBasisType_00_01N_01_4_00_01Function_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Matrix\+Family$<$ Scalar\+Basis\+Type, N $>$, Function $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1detail_1_1basis__evaluation__traits_3_01MatrixFamily_3_01ScalarBasisType_00_01N_01_4_00_01Divergence_01_4}{HAr\+DCore3\+D\+::detail\+::basis\+\_\+evaluation\+\_\+traits$<$ Matrix\+Family$<$ Scalar\+Basis\+Type, N $>$, Divergence $>$}}
\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1evaluate__quad}{HAr\+DCore3\+D\+::evaluate\+\_\+quad$<$ Basis\+Function $>$}}
\begin{DoxyCompactList}\small\item\em Evaluate a basis at quadrature nodes. \textquotesingle{}Basis\+Function\textquotesingle{} (=Function, Gradient, Curl, Divergence or Hessian) determines what kind of value we want to evaluate. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structHArDCore3D_1_1DecomposePoly}{HAr\+DCore3\+D\+::\+Decompose\+Poly$<$ Basis\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Structure to decompose a set of polynomials on a basis on a face or a cell. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceHArDCore3D}{HAr\+DCore3D}}
\item 
 \mbox{\hyperlink{namespaceHArDCore3D_1_1detail}{HAr\+DCore3\+D\+::detail}}
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef Eigen\+::\+Matrix3d \mbox{\hyperlink{group__Basis_gabc4232845eaba80e0a1a45618ed0764d}{HAr\+DCore3\+D\+::\+Matrix\+Rd}}
\item 
{\footnotesize template$<$typename T $>$ }\\using \mbox{\hyperlink{group__Basis_ga5bd2e067b3e9ff0eb5bf5436944076d1}{HAr\+DCore3\+D\+::\+FType}} = std\+::function$<$ T(const Vector\+Rd \&)$>$
\begin{DoxyCompactList}\small\item\em type for function of point. T is the return type of the function \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\using \mbox{\hyperlink{group__Basis_ga523c09e1cb40e9357025dd81596ad752}{HAr\+DCore3\+D\+::\+Cell\+FType}} = std\+::function$<$ T(const Vector\+Rd \&, const Cell $\ast$)$>$
\begin{DoxyCompactList}\small\item\em type for function of point. T is the return type of the function \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\using \mbox{\hyperlink{group__Basis_ga2369d54cfa073699935be349d3d5909b}{HAr\+DCore3\+D\+::\+Basis\+Quad}} = boost\+::multi\+\_\+array$<$ T, 2 $>$
\begin{DoxyCompactList}\small\item\em type for bases evaluated on quadrature nodes \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{group__Basis_ga81eb4732214b7560fbfa4ee9495c6da4}{HAr\+DCore3\+D\+::\+Tensor\+RankE}} \{ \mbox{\hyperlink{group__Basis_gga81eb4732214b7560fbfa4ee9495c6da4af6cb6683b89de3134f2fcf98c26c5b86}{HAr\+DCore3\+D\+::\+Scalar}} = 0
, \mbox{\hyperlink{group__Basis_gga81eb4732214b7560fbfa4ee9495c6da4ad7fecc71e9ca9996ca61eee8542750c0}{HAr\+DCore3\+D\+::\+Vector}} = 1
, \mbox{\hyperlink{group__Basis_gga81eb4732214b7560fbfa4ee9495c6da4a1014fc33583e3e82ee81d9ca08a2d73b}{HAr\+DCore3\+D\+::\+Matrix}} = 2
 \}
\item 
enum \mbox{\hyperlink{group__Basis_ga7be971bd231f83ec8d9cfd644a374180}{HAr\+DCore3\+D\+::\+Basis\+FunctionE}} \{ \newline
\mbox{\hyperlink{group__Basis_gga7be971bd231f83ec8d9cfd644a374180a2238991629c6891194473c41af064389}{HAr\+DCore3\+D\+::\+Function}}
, \mbox{\hyperlink{group__Basis_gga7be971bd231f83ec8d9cfd644a374180a7f9c70dbb7d5d273d385775a4d9c3acd}{HAr\+DCore3\+D\+::\+Gradient}}
, \mbox{\hyperlink{group__Basis_gga7be971bd231f83ec8d9cfd644a374180ae8edfacb373a30cc4ec9136a18d99f0e}{HAr\+DCore3\+D\+::\+Curl}}
, \mbox{\hyperlink{group__Basis_gga7be971bd231f83ec8d9cfd644a374180ac19e39eee83c554fdc002e1747e1ab07}{HAr\+DCore3\+D\+::\+Divergence}}
, \newline
\mbox{\hyperlink{group__Basis_gga7be971bd231f83ec8d9cfd644a374180a65b7fdb019b27a168d64c61622abb34f}{HAr\+DCore3\+D\+::\+Hessian}}
, \mbox{\hyperlink{group__Basis_gga7be971bd231f83ec8d9cfd644a374180a04f70fe52c9028c78c89cf13efe6f8a5}{HAr\+DCore3\+D\+::\+Curl\+Curl}}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Scalar\+Family\+Type $>$ }\\Divergence\+Basis$<$ Tangent\+Family$<$ Scalar\+Family\+Type $>$ $>$ \mbox{\hyperlink{group__Basis_ga46eb884388862e45eb2064a55905ae18}{HAr\+DCore3\+D\+::\+Scalar\+Rot\+Family}} (const Tangent\+Family$<$ Scalar\+Family\+Type $>$ \&tangent\+\_\+family, const Face \&F)
\begin{DoxyCompactList}\small\item\em The following function creates the \char`\"{}scalar rot\char`\"{} basis of a \mbox{\hyperlink{classHArDCore3D_1_1TangentFamily}{Tangent\+Family}} on a face. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename out\+Value , typename in\+Value , typename Function\+Type $>$ }\\boost\+::multi\+\_\+array$<$ out\+Value, 2 $>$ \mbox{\hyperlink{group__Basis_ga95949745fd93384a9364fe5df73034ca}{HAr\+DCore3\+D\+::transform\+\_\+values\+\_\+quad}} (const boost\+::multi\+\_\+array$<$ in\+Value, 2 $>$ \&B\+\_\+quad, const Function\+Type \&F)
\begin{DoxyCompactList}\small\item\em Takes an array B\+\_\+quad of values at quadrature nodes and applies the function F to all of them. F must take in\+Value and return out\+Value. The function must be called with out\+Value as template argument\+: transform\+\_\+values\+\_\+quad$<$out\+Value$>$(...) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar\+Basis\+Type , size\+\_\+t N$>$ }\\Family$<$ Tensorized\+Vector\+Family$<$ Scalar\+Basis\+Type, N $>$ $>$ \mbox{\hyperlink{group__Basis_ga458400e7ff157198d3ec64ab69c4234f}{HAr\+DCore3\+D\+::\+Generic\+Tensorization}} (const Scalar\+Basis\+Type \&B, const std\+::vector$<$ Eigen\+::\+Vector\+Xd $>$ \&v)
\begin{DoxyCompactList}\small\item\em From a scalar family B=(B\+\_\+1..B\+\_\+r) and vectors (v\+\_\+1..v\+\_\+k) in R$^\wedge$N, constructs a \char`\"{}\+Family\char`\"{} of \char`\"{}\+Tensorized\+Vector\+Family\char`\"{} (built on B, of size N) that represents the family (B\+\_\+1v\+\_\+1..B\+\_\+rv\+\_\+1 B\+\_\+1v\+\_\+2...B\+\_\+rv\+\_\+2... B\+\_\+1v\+\_\+k..B\+\_\+rv\+\_\+k). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar\+Basis\+Type , size\+\_\+t N$>$ }\\Family$<$ Matrix\+Family$<$ Scalar\+Basis\+Type, N $>$ $>$ \mbox{\hyperlink{group__Basis_gac5047b78d50c3c5984a644d490e6476a}{HAr\+DCore3\+D\+::\+Isotropic\+Matrix\+Family}} (const Scalar\+Basis\+Type \&B)
\begin{DoxyCompactList}\small\item\em From a scalar family B, constructs a \char`\"{}\+Family\char`\"{} of \char`\"{}\+Matrix\+Family\char`\"{} (built on B, of size NxN) that represents the family B Id on the \mbox{\hyperlink{classHArDCore3D_1_1MatrixFamily}{Matrix\+Family}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga5452c71e3652aa957d105446a95826e8}{HAr\+DCore3\+D\+::gram\+\_\+schmidt}} (boost\+::multi\+\_\+array$<$ T, 2 $>$ \&basis\+\_\+eval, const std\+::function$<$ double(size\+\_\+t, size\+\_\+t)$>$ \&inner\+\_\+product)
\item 
double \mbox{\hyperlink{group__Basis_ga46a7162dd1acacd29421a7d8db89c96e}{HAr\+DCore3\+D\+::scalar\+\_\+product}} (const double \&x, const double \&y)
\begin{DoxyCompactList}\small\item\em Scalar product between two reals. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{group__Basis_gabe66f2d1efad01f907e32517c16b11f9}{HAr\+DCore3\+D\+::scalar\+\_\+product}} (const double \&x, const Eigen\+::\+Matrix$<$ double, 1, 1 $>$ \&y)
\begin{DoxyCompactList}\small\item\em Scalar product between one real and one 1-\/dimension Eigen vector. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{group__Basis_ga0105ef2d1903eeddce62e6ad647a8ead}{HAr\+DCore3\+D\+::scalar\+\_\+product}} (const Vector\+Rd \&x, const Vector\+Rd \&y)
\begin{DoxyCompactList}\small\item\em Scalar product between two vectors. \end{DoxyCompactList}\item 
{\footnotesize template$<$int N$>$ }\\double \mbox{\hyperlink{group__Basis_ga804af14fd89c08b725a2be1cb711fd49}{HAr\+DCore3\+D\+::scalar\+\_\+product}} (const Eigen\+::\+Matrix$<$ double, N, N $>$ \&x, const Eigen\+::\+Matrix$<$ double, N, N $>$ \&y)
\begin{DoxyCompactList}\small\item\em Scalar product between two matrices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Value $>$ }\\boost\+::multi\+\_\+array$<$ double, 2 $>$ \mbox{\hyperlink{group__Basis_ga7c34745cd64a55b7072c5c19e45fa3ec}{HAr\+DCore3\+D\+::scalar\+\_\+product}} (const boost\+::multi\+\_\+array$<$ Value, 2 $>$ \&basis\+\_\+quad, const Value \&v)
\begin{DoxyCompactList}\small\item\em This overloading of the scalar\+\_\+product function computes the scalar product between an evaluation of a basis and a constant value; both basis values and constant value must be of type Value. \end{DoxyCompactList}\item 
boost\+::multi\+\_\+array$<$ Vector\+Rd, 2 $>$ \mbox{\hyperlink{group__Basis_ga7fd6906b30cba10f2f452b029a86ca00}{HAr\+DCore3\+D\+::vector\+\_\+product}} (const boost\+::multi\+\_\+array$<$ Vector\+Rd, 2 $>$ \&basis\+\_\+quad, const Vector\+Rd \&v)
\begin{DoxyCompactList}\small\item\em Compute the vector (cross) product between the evaluation of a basis and a constant vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Basis\+Type $>$ }\\Family$<$ Basis\+Type $>$ \mbox{\hyperlink{group__Basis_ga087cb67abbfba7c2d90f67a4e05abc20}{HAr\+DCore3\+D\+::l2\+\_\+orthonormalize}} (const Basis\+Type \&basis, const Quadrature\+Rule \&qr, boost\+::multi\+\_\+array$<$ typename Basis\+Type\+::\+Function\+Value, 2 $>$ \&basis\+\_\+quad)
\begin{DoxyCompactList}\small\item\em $L^2$-\/orthonormalization\+: simply consists in using \mbox{\hyperlink{group__Basis_ga5452c71e3652aa957d105446a95826e8}{gram\+\_\+schmidt()}} with the specific l2 inner product \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Basis\+Type $>$ }\\Family$<$ Basis\+Type $>$ \mbox{\hyperlink{group__Basis_ga568161021efb47bf500bc9b4eee9ce5e}{HAr\+DCore3\+D\+::l2\+\_\+orthonormalize}} (const Basis\+Type \&basis, const Eigen\+::\+Matrix\+Xd \&GM)
\begin{DoxyCompactList}\small\item\em $L^2$-\/orthonormalization\+: when the Gram Matrix is passed, we use Cholesky. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Function\+Value $>$ }\\Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga224969a8de049faa61bc39d3975bb237}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ Function\+Value, 2 $>$ \&B1, const boost\+::multi\+\_\+array$<$ Function\+Value, 2 $>$ \&B2, const Quadrature\+Rule \&qr, const size\+\_\+t nrows, const size\+\_\+t ncols, const std\+::string sym=\char`\"{}nonsym\char`\"{})
\item 
{\footnotesize template$<$typename Function\+Value $>$ }\\Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga9385a57c81b496ebabea12f8d3c2f068}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ Function\+Value, 2 $>$ \&B1, const boost\+::multi\+\_\+array$<$ Function\+Value, 2 $>$ \&B2, const Quadrature\+Rule \&qr, const std\+::string sym=\char`\"{}nonsym\char`\"{})
\item 
{\footnotesize template$<$typename Function\+Value $>$ }\\Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_gacecea1b90076ee784d7950da4d31749f}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ Function\+Value, 2 $>$ \&B, const Quadrature\+Rule \&qr)
\begin{DoxyCompactList}\small\item\em Compute the Gram matrix given the evaluation of one family of functions at quadrature nodes. Consists in calling the generic templated version with B1=B2. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_gaf5cc3ed71949b5d7adc5877e6bfebcb4}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ Vector\+Rd, 2 $>$ \&B1, const boost\+::multi\+\_\+array$<$ double, 2 $>$ \&B2, const Quadrature\+Rule \&qr)
\begin{DoxyCompactList}\small\item\em Compute the Gram-\/like matrix given a family of vector-\/valued and one of scalar-\/valued functions by tensorizing the latter. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_gac574f3b532690c1d59b2bfc48023ab3b}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ double, 2 $>$ \&B1, const boost\+::multi\+\_\+array$<$ double, 2 $>$ \&B2, const Quadrature\+Rule \&qr, const size\+\_\+t nrows, const size\+\_\+t ncols, const std\+::string sym)
\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_gaf151d3a8c29e1b18fd67b89eae756eca}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ double, 2 $>$ \&B1, const boost\+::multi\+\_\+array$<$ double, 2 $>$ \&B2, const Quadrature\+Rule \&qr, const std\+::string sym)
\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga33b9c4c2ff96b783e8096d584a3e80a9}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ Vector\+Rd, 2 $>$ \&B1, const boost\+::multi\+\_\+array$<$ Vector\+Rd, 2 $>$ \&B2, const Quadrature\+Rule \&qr, const size\+\_\+t nrows, const size\+\_\+t ncols, const std\+::string sym)
\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_gaee4fb375a03e1e4f7d741c6bd26c26e6}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const boost\+::multi\+\_\+array$<$ Vector\+Rd, 2 $>$ \&B1, const boost\+::multi\+\_\+array$<$ Vector\+Rd, 2 $>$ \&B2, const Quadrature\+Rule \&qr, const std\+::string sym=\char`\"{}nonsym\char`\"{})
\begin{DoxyCompactList}\small\item\em Compute the Gram-\/like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the Vector3d-\/valued version with nrows = nb of elements in B1, ncols = nb of elements in B2. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar\+Family\+Type , size\+\_\+t N$>$ }\\Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga190fcba1065188de744af60ae7dc6fe3}{HAr\+DCore3\+D\+::compute\+\_\+gram\+\_\+matrix}} (const Matrix\+Family$<$ Scalar\+Family\+Type, N $>$ \&Mat\+Fam, const boost\+::multi\+\_\+array$<$ double, 2 $>$ \&scalar\+\_\+family\+\_\+quad, const Quadrature\+Rule \&qr)
\begin{DoxyCompactList}\small\item\em Compute the Gram-\/like matrix for a \mbox{\hyperlink{classHArDCore3D_1_1MatrixFamily}{Matrix\+Family}}. This overload is more efficient than the generic function as it only computes the gram matrix of the underlying scalar family, and then creates the bloc-\/diagonal gram matrix of the \mbox{\hyperlink{classHArDCore3D_1_1MatrixFamily}{Matrix\+Family}} (which is indeed bloc diagonal given the choice of m\+\_\+E elements in this class). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\Eigen\+::\+Vector\+Xd \mbox{\hyperlink{group__Basis_ga69278468dd98b9ff1c514877f4705590}{HAr\+DCore3\+D\+::integrate}} (const FType$<$ T $>$ \&f, const Basis\+Quad$<$ T $>$ \&B, const Quadrature\+Rule \&qr, size\+\_\+t n\+\_\+rows=0)
\begin{DoxyCompactList}\small\item\em Computes the vector of integrals (f, phi\+\_\+i) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U $>$ }\\Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga49336d89ac16f3e9babd9df2571f5f26}{HAr\+DCore3\+D\+::compute\+\_\+weighted\+\_\+gram\+\_\+matrix}} (const FType$<$ U $>$ \&f, const Basis\+Quad$<$ T $>$ \&B1, const Basis\+Quad$<$ T $>$ \&B2, const Quadrature\+Rule \&qr, size\+\_\+t n\+\_\+rows=0, size\+\_\+t n\+\_\+cols=0, const std\+::string sym=\char`\"{}nonsym\char`\"{})
\begin{DoxyCompactList}\small\item\em Computes the Gram-\/like matrix of integrals (f phi\+\_\+i, phi\+\_\+j) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U $>$ }\\Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga7553f5c35f39f629060bd6b25710f3fc}{HAr\+DCore3\+D\+::compute\+\_\+weighted\+\_\+gram\+\_\+matrix}} (const FType$<$ U $>$ \&f, const Basis\+Quad$<$ T $>$ \&B1, const Basis\+Quad$<$ T $>$ \&B2, const Quadrature\+Rule \&qr, const std\+::string sym)
\begin{DoxyCompactList}\small\item\em Computes the Gram-\/like matrix of integrals (f phi\+\_\+i, phi\+\_\+j) \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_gaccbfd425467a7d4d3212f43c29c2d6e7}{HAr\+DCore3\+D\+::compute\+\_\+weighted\+\_\+gram\+\_\+matrix}} (const FType$<$ Vector\+Rd $>$ \&f, const Basis\+Quad$<$ Vector\+Rd $>$ \&B1, const Basis\+Quad$<$ double $>$ \&B2, const Quadrature\+Rule \&qr, size\+\_\+t n\+\_\+rows=0, size\+\_\+t n\+\_\+cols=0)
\begin{DoxyCompactList}\small\item\em Computes the Gram-\/like matrix of integrals (f dot phi\+\_\+i, phi\+\_\+j) \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{group__Basis_ga17118956be8fdf8f41886286d37e4fe7}{HAr\+DCore3\+D\+::compute\+\_\+weighted\+\_\+gram\+\_\+matrix}} (const FType$<$ Vector\+Rd $>$ \&f, const Basis\+Quad$<$ double $>$ \&B1, const Basis\+Quad$<$ Vector\+Rd $>$ \&B2, const Quadrature\+Rule \&qr, size\+\_\+t n\+\_\+rows=0, size\+\_\+t n\+\_\+cols=0)
\begin{DoxyCompactList}\small\item\em Computes the Gram-\/like matrix of integrals (phi\+\_\+i, f dot phi\+\_\+j) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Basis\+Type $>$ }\\Eigen\+::\+Vector\+Xd \mbox{\hyperlink{group__Basis_ga658cc3dbb96110d2a295ef85e6d85ecc}{HAr\+DCore3\+D\+::l2\+\_\+projection}} (const std\+::function$<$ typename Basis\+Type\+::\+Function\+Value(const Vector\+Rd \&)$>$ \&f, const Basis\+Type \&basis, Quadrature\+Rule \&quad, const boost\+::multi\+\_\+array$<$ typename Basis\+Type\+::\+Function\+Value, 2 $>$ \&basis\+\_\+quad, const Eigen\+::\+Matrix\+Xd \&mass\+\_\+basis=Eigen\+::\+Matrix\+Xd\+::\+Zero(1, 1))
\begin{DoxyCompactList}\small\item\em Compute the L2-\/projection of a function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
constexpr int \mbox{\hyperlink{group__Basis_ga23a211ab9d745e2e803ad606e1df445f}{HAr\+DCore3\+D\+::dimspace}} = 3
\begin{DoxyCompactList}\small\item\em Dimension, and generic types for vector in correct dimension (makes it easier to translate a code between 2D and 3D) \end{DoxyCompactList}\item 
static std\+::function$<$ Eigen\+::\+Matrix\+Xd(const Eigen\+::\+Matrix\+Xd \&)$>$ \mbox{\hyperlink{group__Basis_ga2955b556916319159c65a1b2e45f9364}{HAr\+DCore3\+D\+::symmetrise\+\_\+matrix}} = \mbox{[}$\,$\mbox{]}(const Eigen\+::\+Matrix\+Xd \& x)-\/$>$Eigen\+::\+Matrix\+Xd \{ return 0.\+5$\ast$(x+x.\+transpose());\}
\begin{DoxyCompactList}\small\item\em Function to symmetrise a matrix (useful together with transform\+\_\+values\+\_\+quad) \end{DoxyCompactList}\item 
static std\+::function$<$ Eigen\+::\+Matrix\+Xd(const Eigen\+::\+Matrix\+Xd \&)$>$ \mbox{\hyperlink{group__Basis_gaed3cea3b025e9f753fb238c826b48f84}{HAr\+DCore3\+D\+::skew\+\_\+symmetrise\+\_\+matrix}} = \mbox{[}$\,$\mbox{]}(const Eigen\+::\+Matrix\+Xd \& x)-\/$>$Eigen\+::\+Matrix\+Xd \{ return 0.\+5$\ast$(x-\/x.\+transpose());\}
\begin{DoxyCompactList}\small\item\em Function to skew-\/symmetrise a matrix (useful together with transform\+\_\+values\+\_\+quad) \end{DoxyCompactList}\end{DoxyCompactItemize}
