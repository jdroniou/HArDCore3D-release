\hypertarget{classHArDCore3D_1_1HybridCore}{}\doxysection{H\+Ar\+D\+Core3D\+::Hybrid\+Core Class Reference}
\label{classHArDCore3D_1_1HybridCore}\index{HArDCore3D::HybridCore@{HArDCore3D::HybridCore}}


{\ttfamily \#include $<$hybridcore.\+hpp$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \mbox{\hyperlink{classHArDCore3D_1_1Family}{Family}}$<$ \mbox{\hyperlink{classHArDCore3D_1_1MonomialScalarBasisCell}{Monomial\+Scalar\+Basis\+Cell}} $>$ \mbox{\hyperlink{group__HybridCore_ga5c478c9953257f154d2ea98f115fba0d}{Poly\+Cell\+Basis\+Type}}
\begin{DoxyCompactList}\small\item\em type for cell basis \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{classHArDCore3D_1_1Family}{Family}}$<$ \mbox{\hyperlink{classHArDCore3D_1_1MonomialScalarBasisFace}{Monomial\+Scalar\+Basis\+Face}} $>$ \mbox{\hyperlink{group__HybridCore_gab02b7a4490b6a739e2d084e9a70dbcc5}{Poly\+Face\+Basis\+Type}}
\begin{DoxyCompactList}\small\item\em type for face basis \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{classHArDCore3D_1_1Family}{Family}}$<$ \mbox{\hyperlink{classHArDCore3D_1_1MonomialScalarBasisEdge}{Monomial\+Scalar\+Basis\+Edge}} $>$ \mbox{\hyperlink{group__HybridCore_gad3123dceabd79eec7cdb57ba1014fc17}{Poly\+Edge\+Basis\+Type}}
\begin{DoxyCompactList}\small\item\em type for edge basis \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__HybridCore_ga0afcdbfe52e163c27b24ec93d336dc53}{Hybrid\+Core}} (const \mbox{\hyperlink{classMeshND_1_1Mesh}{Mesh}} $\ast$mesh\+\_\+ptr, const int cell\+\_\+deg, const size\+\_\+t face\+\_\+deg, const int edge\+\_\+deg, const bool use\+\_\+threads=true, std\+::ostream \&output=std\+::cout, const bool ortho=true)
\begin{DoxyCompactList}\small\item\em Class constructor\+: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{classMeshND_1_1Mesh}{Mesh}} $\ast$ \mbox{\hyperlink{group__HybridCore_gaf9413be657df06123c1544d16df6b137}{get\+\_\+mesh}} () const
\begin{DoxyCompactList}\small\item\em Returns a pointer to the mesh. \end{DoxyCompactList}\item 
const int \mbox{\hyperlink{group__HybridCore_ga10e8b9bd521b54042cccd84520011fe9}{Cell\+Degree}} () const
\begin{DoxyCompactList}\small\item\em Return the degree of cell polynomials. \end{DoxyCompactList}\item 
const int {\bfseries Cell\+Degree\+Pos} () const
\item 
const size\+\_\+t \mbox{\hyperlink{group__HybridCore_gabd72ee1721337185ed3c39da286e2928}{Face\+Degree}} () const
\begin{DoxyCompactList}\small\item\em Return the degree of face polynomials. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{group__HybridCore_ga5c478c9953257f154d2ea98f115fba0d}{Poly\+Cell\+Basis\+Type}} \& \mbox{\hyperlink{group__HybridCore_gafb3d4f37c8aef9a9b74f015bd2da41ea}{Cell\+Basis}} (size\+\_\+t iT) const
\begin{DoxyCompactList}\small\item\em Return cell basis for element with global index iT. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{group__HybridCore_gab02b7a4490b6a739e2d084e9a70dbcc5}{Poly\+Face\+Basis\+Type}} \& \mbox{\hyperlink{group__HybridCore_ga5db5bc8811abd5cb2a264486f61c0ad2}{Face\+Basis}} (size\+\_\+t iF) const
\begin{DoxyCompactList}\small\item\em Return face basis for face with global index iF. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{group__HybridCore_gad3123dceabd79eec7cdb57ba1014fc17}{Poly\+Edge\+Basis\+Type}} \& \mbox{\hyperlink{group__HybridCore_ga21071e365011fbb477a70475f7642f02}{Edge\+Basis}} (size\+\_\+t iE) const
\begin{DoxyCompactList}\small\item\em Return edge basis for edge with global index iE. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{group__HybridCore_gab37ab89bf946e237821dd978f475b7c8}{L2norm}} (const \mbox{\hyperlink{classHArDCore3D_1_1UVector}{U\+Vector}} \&Xh) const
\begin{DoxyCompactList}\small\item\em Compute L2 norm of a discrete function (using cell values) \end{DoxyCompactList}\item 
double \mbox{\hyperlink{group__HybridCore_gad6672e0691764ec5752eb1a9a7257792}{H1norm}} (const \mbox{\hyperlink{classHArDCore3D_1_1UVector}{U\+Vector}} \&Xh) const
\begin{DoxyCompactList}\small\item\em Compute discrete H1 norm of a discrete function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Continuous\+Function $>$ }\\\mbox{\hyperlink{classHArDCore3D_1_1UVector}{U\+Vector}} \mbox{\hyperlink{group__HybridCore_gadce852531f9197a35e11e1bf9995e827}{interpolate}} (const Continuous\+Function \&f, const int deg\+\_\+cell, const size\+\_\+t deg\+\_\+face, size\+\_\+t doe) const
\begin{DoxyCompactList}\small\item\em Compute the interpolant in the discrete space of a continuous function. \end{DoxyCompactList}\item 
Eigen\+::\+Vector\+Xd \mbox{\hyperlink{group__HybridCore_ga06825c5d156026d465a2798389aa952b}{compute\+\_\+weights}} (size\+\_\+t iT) const
\begin{DoxyCompactList}\small\item\em Computes the weights to get cell values from face values when l=-\/1. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{group__HybridCore_ga9c76abf42a1d56fbf863d8258690497c}{evaluate\+\_\+in\+\_\+cell}} (const \mbox{\hyperlink{classHArDCore3D_1_1UVector}{U\+Vector}} Xh, size\+\_\+t iT, Vector\+Rd x) const
\begin{DoxyCompactList}\small\item\em Evaluates a discrete function in the cell iT at point x. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{group__HybridCore_ga088adb7dbbde4b63229b404ee72ed9ea}{evaluate\+\_\+in\+\_\+face}} (const \mbox{\hyperlink{classHArDCore3D_1_1UVector}{U\+Vector}} Xh, size\+\_\+t iF, Vector\+Rd x) const
\begin{DoxyCompactList}\small\item\em Evaluates a discrete function on the face iF at point x. \end{DoxyCompactList}\item 
Eigen\+::\+Vector\+Xd \mbox{\hyperlink{group__HybridCore_ga1d33ec0786b8127a161384ecf8f04018}{Vertex\+Values}} (const \mbox{\hyperlink{classHArDCore3D_1_1UVector}{U\+Vector}} Xh, const std\+::string from\+\_\+dofs)
\begin{DoxyCompactList}\small\item\em From a hybrid function, computes a vector of values at the vertices of the mesh. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The \mbox{\hyperlink{classHArDCore3D_1_1HybridCore}{Hybrid\+Core}} class provides an interface for generating polynomial basis functions on cell, faces and edges, interpolation of continuous functions, discrete norms of vectors of coefficients, and methods to evaluate discrete functions (given by vectors of coefficients) in the cells, on the faces, or at vertices (averaged of cell or face values)

The current implementation has the following behaviours/expectations\+:
\begin{DoxyItemize}
\item Face polynomials must be at least of degree 0, and face basis functions are always generated
\item Cell polynomials could be of degree -\/1, or 0+. In the former case, basis functions of degree 0 are generated, but a function is provided to compute weights to express the cell values in terms of linearly exact averages of face values. This function is used, e.\+g., when interpolating a continuous function.
\item Edge polynomials could be of degree 0+, or -\/1 in which case the edge basis functions are not generated 
\end{DoxyItemize}

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\+Hybrid\+Core/hybridcore.\+hpp\item 
src/\+Hybrid\+Core/hybridcore.\+cpp\end{DoxyCompactItemize}
